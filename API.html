<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="github-markdown.css">
<style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
</style>
<article class="markdown-body">



<h1 id="code-12-api-documentation">Code 12 API Documentation</h1>
<p>The design of the Code 12 API is (c)Copyright 2018 by David C. Parker.</p>
<h5 id="global-ct-apis">Global (ct) APIs</h5>
<ul>
<li><a href="#text-output">Text Output</a></li>
<li><a href="#text-input">Text Input</a></li>
<li><a href="#screen-management">Screen Management</a></li>
<li><a href="#gameobj-creation">GameObj Creation</a></li>
<li><a href="#mouse-and-keyboard-input">Mouse and Keyboard Input</a></li>
<li><a href="#audio">Audio</a></li>
<li><a href="#math-and-misc">Math and Misc.</a></li>
<li><a href="#type-conversion">Type Conversion</a></li>
</ul>
<h5 id="gameobj-fields-and-methods">GameObj Fields and Methods</h5>
<ul>
<li><a href="#gameobj-public-data-fields">GameObj Public Data Fields</a></li>
<li><a href="#gameobj-methods">GameObj Methods</a></li>
</ul>
<h5 id="java-class-methods-and-fields-supported">Java Class Methods and Fields Supported</h5>
<ul>
<li><a href="#java-math-class-methods-and-fields-supported">Math Class</a></li>
<li><a href="#java-string-class-methods-supported">String Class</a></li>
</ul>
<h5 id="events-client-functions-">Events (Client Functions)</h5>
<ul>
<li><a href="#events">Events</a></li>
</ul>
<h5 id="appendix-pre-defined-names">Appendix: Pre-Defined Names</h5>
<ul>
<li><a href="#color-names">Color Names</a></li>
<li><a href="#key-names">Key Names</a></li>
</ul>
<hr>
<h2 id="text-output">Text Output</h2>
<h3 id="ct-print-">ct.print()</h3>
<pre><code>ct.print( Object obj )
</code></pre><p>Print the text representation of a value to the console. The <code>obj</code> can be a value of any type. No newline or extra characters are added.</p>
<blockquote>
<p>This is equivalent to Java&#39;s <code>System.out.print</code>.</p>
</blockquote>
<h3 id="ct-println-">ct.println()</h3>
<pre><code>ct.println( Object obj )
ct.println( )
</code></pre><p>Print the text representation of a value to the console, and add a newline afterwards. The <code>obj</code> can be a value of any type. If <code>obj</code> is not included, just a newline is printed.</p>
<blockquote>
<p>This is equivalent to Java&#39;s <code>System.out.println</code>.</p>
</blockquote>
<h3 id="ct-log-">ct.log()</h3>
<pre><code>ct.log( Object… objs )
</code></pre><p>Print any number of values to the console. There can be any number of values passed, of any types. If multiple values are given, they are printed on one line separated by commas. Strings are enclosed in <code>&quot;double quotes&quot;</code>, and <code>GameObj</code> objects are described in <code>[square brackets]</code>.</p>
<h3 id="ct-logm-">ct.logm()</h3>
<pre><code>ct.logm( String message, Object… objs )
</code></pre><p>Print the <code>message</code> followed by a space, then print any number of values to the console. The values are output in the same way as <code>ct.logm()</code> (see above).</p>
<hr>
<h2 id="text-input">Text Input</h2>
<h3 id="ct-inputint-">ct.inputInt()</h3>
<pre><code>int ct.inputInt( String message )
</code></pre><p>If <code>message</code> is not null then print it to the console followed by a space. Then, accept input from the console until a newline is entered. Attempt to parse the input as an integer. If a valid integer is input then return the integer, otherwise return 0.</p>
<h3 id="ct-inputnumber-">ct.inputNumber()</h3>
<pre><code>double ct.inputNumber( String message )
</code></pre><p>If <code>message</code> is not null then print it to the console followed by a space. Then, accept input from the console until a newline is entered. Attempt to parse the input as a number. If a valid number is input then return the number, otherwise return an error value (NaN). You can test for an error value using <code>ct.isError()</code>.</p>
<h3 id="ct-inputboolean-">ct.inputBoolean()</h3>
<pre><code>boolean ct.inputBoolean( String message )
</code></pre><p>If <code>message</code> is not null then print it to the console followed by a space. Then, accept input from the console until a newline is entered. If the first non-blank character of the input is &#39;y&#39;, &#39;Y&#39;, &#39;t&#39;, &#39;T&#39;, or 1 (yes, true, or 1), then return true, otherwise return false.</p>
<h3 id="ct-inputstring-">ct.inputString()</h3>
<pre><code>String ct.inputString( String message )
</code></pre><p>If <code>message</code> is not null then print it to the console followed by a space. Then, accept input from the console until a newline is entered. Return the entire input as a String.</p>
<hr>
<h2 id="screen-management">Screen Management</h2>
<h3 id="ct-settitle-">ct.setTitle()</h3>
<pre><code>ct.setTitle( String title )
</code></pre><p>Set the title of the application window to <code>title</code>. If and where the title displays depends on the platform that the application is running on. The title will not display on mobile devices.</p>
<h3 id="ct-setheight-">ct.setHeight()</h3>
<pre><code>ct.setHeight( double height )
</code></pre><p>Set the height of the application window, relative to its width, to <code>height</code>, as a percent. The width of the application window in display units is always 100, so this function determines the maximum y-coordinate value inside the window. The default height is 100 if not set (resulting in a square window).</p>
<blockquote>
<p><strong>Note</strong>: On some platforms, you may have limited or no control over the window size. On mobile devices, the application will always fill the entire device screen. In this case, this function will determine whether the application runs in portrait or landscape orientation. If <code>height</code> is less than 100 then the application will run in landscape mode, otherwise portrait mode.</p>
</blockquote>
<blockquote>
<p>After calling <code>ct.setHeight()</code>, you can call <code>ct.getHeight()</code> to determine the actual height of the window (and thus the maximum y-coordinate).</p>
</blockquote>
<h5 id="examples">Examples</h5>
<pre><code>ct.setHeight( 100 );               // default square window
ct.setHeight( 200 );               // window is twice as tall as wide
ct.setHeight( 100.0 * 9 / 16 );    // 16:9 aspect landscape
double height = ct.getHeight();    // get actual height used
</code></pre><h3 id="ct-getwidth-">ct.getWidth()</h3>
<pre><code>double ct.getWidth( )
</code></pre><p>This function always returns 100.0, which is the width of the application window in coordinate units by definition. This is the maximum x-coordinate that is inside the window (the right edge).</p>
<h3 id="ct-getheight-">ct.getHeight()</h3>
<pre><code>double ct.getHeight( )
</code></pre><p>Return the maximum y-coordinate value that is inside the application window (the bottom edge).</p>
<h3 id="ct-getpixelsperunit-">ct.getPixelsPerUnit()</h3>
<pre><code>double ct.getPixelsPerUnit( )
</code></pre><p>Return the current scale factor from display coordinate units to device pixels. The contents of your application scale automatically relative to the window size, and the width of the window is always defined as 100 in coordinate units. If you want to determine the physical size of the application window in pixels, you can calculate this as:</p>
<pre><code>int pixelWidth = ct.round( ct.getWidth() * ct.getPixelsPerUnit() );
int pixelHeight = ct.round( ct.getHeight() * ct.getPixelsPerUnit() );
</code></pre><blockquote>
<p>Note that the definition of a &quot;pixel&quot; is platform-dependent, and some devices with very high resolution (e.g. 4K or Retina) may use more than 1 physical pixel per reported &quot;pixel&quot;.</p>
</blockquote>
<h3 id="ct-getscreen-">ct.getScreen()</h3>
<pre><code>String ct.getScreen( )
</code></pre><p>Return the name of the current screen. Your application can define multiple named screens and switch between them (see <code>ct.setScreen()</code>). The default screen name is &quot;&quot; (empty string) if it has not been changed.</p>
<h3 id="ct-setscreen-">ct.setScreen()</h3>
<pre><code>ct.setScreen( String name )
</code></pre><p>Set the current application screen to the screen named <code>name</code>. Your application can define multiple named screens and switch between them. Each screen has its own background and its own <code>GameObj</code> objects.</p>
<p>If a screen named <code>name</code> is not already known, then create a new empty screen with this name and set it as the current screen.</p>
<p><code>GameObj</code> objects that are created are always created on the current screen, so to create two screens in your <code>start</code> function:</p>
<ol>
<li>Call <code>ct.setScreen()</code> to name the first screen</li>
<li>Create <code>GameObj</code> objects for the first screen</li>
<li>Call <code>ct.setScreen()</code> to name the second screen</li>
<li>Create <code>GameObj</code> objects for the second screen</li>
<li>At the end of <code>start</code>, call <code>ct.setScreen()</code> to set the desired starting screen for your application.</li>
</ol>
<h3 id="ct-clearscreen-">ct.clearScreen()</h3>
<pre><code>ct.clearScreen( )
</code></pre><p>Remove and delete all <code>GameObj</code> objects on the current screen. The background color or image is kept.</p>
<h3 id="ct-cleargroup-">ct.clearGroup()</h3>
<pre><code>ct.clearGroup( String group )
</code></pre><p>Remove and delete all <code>GameObj</code> objects on the current screen whose group name (see the <code>group</code> field of a <code>GameObj</code>) matches the <code>group</code> passed.</p>
<p>The default group name for objects not assigned a group name is &quot;&quot; (empty string).</p>
<h3 id="ct-setbackcolor-">ct.setBackColor()</h3>
<pre><code>ct.setBackColor( String color )
</code></pre><p>Set the background color of the current screen to the pre-defined color named <code>color</code>. See <a href="#color-names">Color Names</a>.</p>
<h3 id="ct-setbackcolorrgb-">ct.setBackColorRGB()</h3>
<pre><code>ct.setBackColorRGB( int r, int g, int b )
</code></pre><p>Set the background color of the current screen to the custom RGB color with components <code>r</code>, <code>g</code>, and <code>b</code> in the range 0-255.</p>
<h3 id="ct-setbackimage-">ct.setBackImage()</h3>
<pre><code>ct.setBackImage( String filename )
</code></pre><p>Set the background image of the current screen to the image <code>filename</code>. The image file must be in PNG or JPG format. The background image is centered and cropped automatically to show as much of the image as possible given the aspect ratio of the window, while preserving the aspect ratio of the image.</p>
<p>If <code>filename</code> is a simple filename (no path), then the main project folder is checked first, followed by the <code>Code12/images</code> folder if not found in the project folder.</p>
<hr>
<h2 id="gameobj-creation">GameObj Creation</h2>
<h3 id="ct-circle-">ct.circle()</h3>
<pre><code>GameObj ct.circle( double x, double y, double diameter )
GameObj ct.circle( double x, double y, double diameter, String color )
</code></pre><p>Create and add a circle object to the current screen with the given (<code>x</code>, <code>y</code>) location and <code>diameter</code>. Return the <code>GameObj</code> reference to the circle object.</p>
<p>Circle objects default to a fill color of &quot;red&quot;, a line color of &quot;black&quot;, and a line width of 1. If <code>color</code> is included then set the circle&#39;s fill color to the given named color. See <a href="#color-names">Color Names</a>.</p>
<h3 id="ct-rect-">ct.rect()</h3>
<pre><code>GameObj ct.rect( double x, double y, double width, double height )
GameObj ct.rect( double x, double y, double width, double height, String color )
</code></pre><p>Create and add a rectangle object to the current screen with the given (<code>x</code>, <code>y</code>) location and size given by <code>width</code> and <code>height</code>. Return the <code>GameObj</code> reference to the rectangle object.</p>
<p>Rectangle objects default to a fill color of &quot;yellow&quot;, a line color of &quot;black&quot;, and a line width of 1. If <code>color</code> is included then set the rectangle&#39;s fill color to the given named color. See <a href="#color-names">Color Names</a>.</p>
<h3 id="ct-line-">ct.line()</h3>
<pre><code>GameObj ct.line( double x1, double y1, double x2, double y2 )
GameObj ct.line( double x1, double y1, double x2, double y2, String color )
</code></pre><p>Create and add a line object to the current screen from point (<code>x1</code>, <code>y1</code>) to point (<code>x2</code>, <code>y2</code>). Return the <code>GameObj</code> reference to the line object.</p>
<p>Line objects default to a line color of &quot;black&quot;, and a line width of 1. (Lines have no fill color). If <code>color</code> is included then set the line&#39;s color to the given named color See <a href="#color-names">Color Names</a>.</p>
<h3 id="ct-text-">ct.text()</h3>
<pre><code>GameObj ct.text( String s, double x, double y, double height )
GameObj ct.text( String s, double x, double y, double height, String color )
</code></pre><p>Create and add a text object to the current screen with text string <code>s</code>, at location (<code>x</code>, <code>y</code>), and height given by <code>height</code>. The font size is determined automatically to fit within the <code>height</code>. The object width is determined automatically to be wide enough to contain the string <code>s</code> on one line. Return the <code>GameObj</code> reference to the text object.</p>
<p>Text objects default to a text (fill) color of &quot;black&quot; and have no line color. If <code>color</code> is included then set the text&#39;s color to the given named color. See <a href="#color-names">Color Names</a>.</p>
<h3 id="ct-image-">ct.image()</h3>
<pre><code>GameObj ct.image( String filename, double x, double y, double width )
</code></pre><p>Create and add an image object to the current screen with the image <code>filename</code>, at location (<code>x</code>, <code>y</code>), and width given by <code>width</code>. The height is determined automatically to preserve the original image&#39;s aspect ratio. Return the <code>GameObj</code> reference to the image object.</p>
<p>The image file must be in PNG or JPG format.</p>
<hr>
<h2 id="mouse-and-keyboard-input">Mouse and Keyboard Input</h2>
<h3 id="ct-clicked-">ct.clicked()</h3>
<pre><code>boolean ct.clicked( )
</code></pre><p>Return <code>true</code> if a mouse click or touch occured in the application window during the last update cycle. Calling this function every time in your <code>update</code> function will detect all mouse clicks.</p>
<p>If this function returns true then you can retrive the click location using <code>ct.clickX()</code> and <code>ct.clickY()</code>.</p>
<h3 id="ct-clickx-">ct.clickX()</h3>
<pre><code>double ct.clickX( )
</code></pre><p>Return the x-coordinate of the last known click, touch, or drag location in the application.</p>
<h3 id="ct-clicky-">ct.clickY()</h3>
<pre><code>double ct.clickY( )
</code></pre><p>Return the y-coordinate of the last known click, touch, or drag location in the application.</p>
<h3 id="ct-keypressed-">ct.keyPressed()</h3>
<pre><code>boolean ct.keyPressed( String keyName )
</code></pre><p>Return <code>true</code> if the key named <code>keyName</code> is currently pressed (the key is down). See <a href="#key-names">Key Names</a>. Note that multiple keys can be down at the same time.</p>
<h3 id="ct-chartyped-">ct.charTyped()</h3>
<pre><code>boolean ct.charTyped( String ch )
</code></pre><p>Return <code>true</code> if the printable character <code>ch</code> was typed during the last update cycle.</p>
<p>Calling this function every time in your <code>update</code> function will detect any time that the given character is typed.</p>
<blockquote>
<p>Unlike the key names used by <code>ct.keyPressed()</code>, the <code>ch</code> here is a printable character including the appropriate shift status (e.g. &quot;A&quot; if a shifted &quot;a&quot; is typed, &quot;$&quot; or &quot;4&quot;, &quot;+&quot; vs. &quot;=&quot;, etc.). Only printable characters are detected, so key sequences such as Ctrl+C do not result in characters.</p>
</blockquote>
<blockquote>
<p>Note that some platforms may have keys that auto-repeat when held down, so if you check <code>ct.charTyped()</code> every time in your <code>update</code> function, and the user holds down a key, you may get the first character, then perhaps a 1 second delay, then repeats at around 8 characters per second. Contrast this with using <code>ct.keyPressed()</code> instead, where you will get a <code>true</code> result continuously (60 times per second), and no delay after the first one.</p>
</blockquote>
<hr>
<h2 id="audio">Audio</h2>
<h3 id="ct-sound-">ct.sound()</h3>
<pre><code>ct.sound( String filename )
</code></pre><p>Play the sound effect in the sound file <code>filename</code>.</p>
<blockquote>
<p>Only standard formats of WAV sounds are reliable on all platforms, although other platforms may support MP3 and others.</p>
</blockquote>
<blockquote>
<p>The sound starts playing, <code>ct.sound()</code> returns immediately, then the sound continues to play in another thread. Playing another sound while the first sound is still playing may result in mixing the two sounds. However, some platforms may not implement sound mixing, in which case attempting to play a sound while another sound is playing will be ignored.</p>
</blockquote>
<h3 id="ct-setsoundvolume-">ct.setSoundVolume()</h3>
<pre><code>ct.setSoundVolume( double volume )
</code></pre><p>Set the relative volume to use for sounds played by <code>ct.sound()</code> to <code>volume</code>, which should be between 0.0 and 1.0. The default sound volume is 1.0. If the volume is decreased then sounds are attenuated relative to the volume they were recorded at.</p>
<hr>
<h2 id="math-and-misc">Math and Misc.</h2>
<h3 id="ct-random-">ct.random()</h3>
<pre><code>int ct.random( int min, int max )
</code></pre><p>Return a random integer from <code>min</code> to <code>max</code> (inclusive).</p>
<h3 id="ct-round-">ct.round()</h3>
<pre><code>int ct.round( double d )
double ct.round( double d, int numPlaces )
</code></pre><p>If <code>numPlaces</code> is included, then return the number <code>d</code> rounded to that number of decimal places.</p>
<p>If <code>numPlaces</code> is not included, then return the number <code>d</code> rounded to the nearest integer.</p>
<h3 id="ct-intdiv-">ct.intDiv()</h3>
<pre><code>int ct.intDiv( int n, int d )
</code></pre><p>Return the result of an integer divide of n / d. If n / d is not an integer, the result is rounded down to the next smaller integer. If d is 0 then the result is a large positive integer if n &gt; 0, a large negative integer if n &lt; 0, and 0 if n is 0. </p>
<h3 id="ct-iserror-">ct.isError()</h3>
<pre><code>boolean ct.isError( double d )
</code></pre><p>Return <code>true</code> if the value of <code>d</code> is an error value (NaN = &quot;Not a Number&quot;).</p>
<h3 id="ct-distance-">ct.distance()</h3>
<pre><code>double ct.distance( double x1, double y1, double x2, double y2 )
</code></pre><p>Return the distance between the points (<code>x1</code>, <code>y1</code>) and (<code>x2</code>, <code>y2</code>).</p>
<h3 id="ct-gettimer-">ct.getTimer()</h3>
<pre><code>int ct.getTimer( )
</code></pre><p>Return the number of milliseconds since the application started. Time starts at the begining of the <code>start</code> function.</p>
<h3 id="ct-getversion-">ct.getVersion()</h3>
<pre><code>double getVersion( )
</code></pre><p>Return the version number of the Code12 runtime system.</p>
<hr>
<h2 id="type-conversion">Type Conversion</h2>
<h3 id="ct-toint-">ct.toInt()</h3>
<pre><code>int ct.toInt( double d )
</code></pre><p>Return the value <code>d</code> truncated to an integer.</p>
<blockquote>
<p>All decimal places are lost. This is equivalent to a type cast from double to int. If you wish to round, use <code>ct.round()</code> instead.</p>
</blockquote>
<h3 id="ct-parseint-">ct.parseInt()</h3>
<pre><code>int ct.parseInt( String s )
</code></pre><p>If <code>s</code> can be converted to (parsed as) an integer, then return the integer value, otherwise return 0.</p>
<blockquote>
<p>Since 0 is a valid integer, it is a good idea to test the string with <code>ct.canParseInt()</code> first.</p>
</blockquote>
<h3 id="ct-canparseint-">ct.canParseInt()</h3>
<pre><code>boolean ct.canParseInt( String s )
</code></pre><p>If <code>s</code> can be converted to (parsed as) an integer, then return <code>true</code>, otherwise return <code>false</code>.</p>
<h3 id="ct-parsenumber-">ct.parseNumber()</h3>
<pre><code>double ct.parseNumber( String s )
</code></pre><p>If <code>s</code> can be converted to (parsed as) a number, then return the value as a <code>double</code>, otherwise return the NaN (Not a Number) error value.</p>
<blockquote>
<p>To test for NaN, use <code>ct.isError()</code></p>
</blockquote>
<h3 id="ct-canparsenumber-">ct.canParseNumber()</h3>
<pre><code>boolean ct.canParseNumber( String s )
</code></pre><p>If <code>s</code> can be converted to (parsed as) a number, then return <code>true</code>, otherwise return <code>false</code>.</p>
<h3 id="ct-formatdecimal-">ct.formatDecimal()</h3>
<pre><code>String ct.formatDecimal( double d )
String ct.formatDecimal( double d, int numPlaces )
</code></pre><p>Return the value of <code>d</code> converted to a string. If <code>numPlaces</code> is included, then format the output to exactly this many places past the decimal point, rounding or adding extra zeros as necessary.</p>
<h3 id="ct-formatint-">ct.formatInt()</h3>
<pre><code>String ct.formatInt( int i )
String ct.formatInt( int i, int numDigits )
</code></pre><p>Return the value of <code>i</code> converted to a string. If numDigits is included, then format to this many digits, adding leading zeros as necessary.</p>
<hr>
<h2 id="gameobj-public-data-fields">GameObj Public Data Fields</h2>
<p><code>GameObj</code> objects are graphics objects visible on the screen. See <a href="#gameobj-creation">GameObj Creation</a> to create a <code>GameObj</code>. All <code>GameObj</code> objects have the following public data fields, which can be accessed or assigned to at any time. If assigned to, the new value takes effect at the next update cycle.</p>
<h3 id="x-y">x, y</h3>
<pre><code>double x, y
</code></pre><p>The <code>x</code> and <code>y</code> fields specify the position of the object in the application window, in graphics coordinates. By default, graphics coordinates range from 0 to 100 in both x and y if the window is square. If the window is not square (see <code>ct.setHeight()</code>), then x coordinates still range from 0 (left edge) to 100 (right edge), but y coordiantes will range from 0 (top edge) to the value returned by <code>ct.getHeight()</code> (bottom edge).</p>
<blockquote>
<p>By default, objects are positioned by their center, so (<code>x</code>, <code>y</code>) will be the center of the object. However, this can be modified by the <code>GameObj</code> method <code>obj.align()</code>.</p>
</blockquote>
<blockquote>
<p>It is not an error to position an object outside the application window, it will simply not be visible or will clip at the window boundary.</p>
</blockquote>
<h3 id="width-height">width, height</h3>
<pre><code>double width, height
</code></pre><p>The <code>width</code> and <code>height</code> fields specify the size of the object in graphics coordinates. The different types of <code>GameObj</code> objects react somewhat differently to changes in size, as follows:</p>
<h5 id="circle">circle</h5>
<p>Although circles are always created round, you can create an ellipse by setting different <code>width</code> and <code>height</code> values.</p>
<h5 id="rect">rect</h5>
<p>Rectangles can be any size and adjust to any <code>width</code> and <code>height</code>.</p>
<h5 id="line">line</h5>
<p>Line objects are created between two points. After creation, the <code>x</code> and <code>y</code> fields are the location of the first point, and the <code>width</code> and <code>height</code> fields specify signed offsets (can be negative) from the first point to the second point. Thus, the location of the second point is (<code>x</code> + <code>width</code>, <code>y</code> + <code>height</code>). You can change any of the <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code> fields, and the line will adjust.</p>
<blockquote>
<p>Note that unlike any of the other <code>GameObj</code> object types, a line may have negative values for the <code>width</code> and <code>height</code> fields. The physical width and height of the line&#39;s bounding box can be reliably determined with <code>Math.abs(line.width)</code> and <code>Math.abs(line.height)</code>. This does not include the thickness of the drawn line itself (see <code>lineWidth</code> below).</p>
</blockquote>
<h5 id="text">text</h5>
<p>Text objects use a font size that is automatically determined by the object&#39;s <code>height</code>, and the object&#39;s <code>width</code> is calculated automatically. So, changing <code>height</code> will change the font size, and changes to the <code>width</code> field are undefined.</p>
<blockquote>
<p><strong>Note:</strong> When you change a text object&#39;s <code>height</code>, the <code>width</code> will be recalculated automatically. However, the new value for <code>width</code> is not available immediately. It will be recalculated the next time the object draws (during the next update cycle).</p>
</blockquote>
<h5 id="image">image</h5>
<p>Images are initially created with <code>height</code> calculated automatically to preserve the image&#39;s aspect ratio given the specified <code>width</code>. However, once created, you can set any values for <code>width</code> and <code>height</code>, and the image will scale and/or stretch as necessary to fill the space.</p>
<h3 id="xspeed-yspeed">xSpeed, ySpeed</h3>
<pre><code>double xSpeed, ySpeed
</code></pre><p>The <code>xSpeed</code> and <code>ySpeed</code> fields can be used to make an object move automatically at the specified speed and direction. The <code>xSpeed</code> and <code>ySpeed</code> values are added to the object&#39;s <code>x</code> and <code>y</code> fields at the beginning of each update cycle. Update cycles happen 60 times per second, so setting <code>xSpeed</code> to 1 will make the object move 60 units per second to the right. The values for <code>xSpeed</code> and <code>ySpeed</code> can be positive or negative, and they both default to 0.</p>
<blockquote>
<p>You can change <code>xSpeed</code> and/or <code>ySpeed</code> at any time to change the speed or direction of an object.</p>
</blockquote>
<h3 id="linewidth">lineWidth</h3>
<pre><code>int lineWidth
</code></pre><p>If an object has a line color (see the <code>GameObj</code> methods <code>obj.setLineColor()</code> and <code>obj.setLineColorRGB()</code>), then the object will be outlined in this color with a stroke of approximately <code>lineWidth</code> pixels. The default is 1.</p>
<blockquote>
<p>Unlike normal coordinate values, <code>lineWidth</code> values are measured in approximate device &quot;pixels&quot;, so apparent line thickness does not scale up as the window size is increased. The definition of &quot;pixels&quot; depends on the platform and may vary, but the overall intent is that on a screen of &quot;normal&quot; resolution (e.g. HD resolution, not 4K or Retina), a <code>lineWidth</code> of 1 will result in an appoximate 1 pixel border. High resolution screens may use multiple pixels, and some platforms may use partial pixels for a smoother appearance (anti-aliasing).</p>
</blockquote>
<h3 id="visible">visible</h3>
<pre><code>boolean visible
</code></pre><p>The <code>visible</code> field defaults to <code>true</code>, but you can set it to <code>false</code> to hide the object. Hidden objects are effectively disabled, and will not draw or respond to mouse/touch input.</p>
<h3 id="clickable">clickable</h3>
<pre><code>boolean clickable
</code></pre><p>Set the <code>clickable</code> field of an object to <code>true</code> (default <code>false</code>) to make it respond to mouse/touch input. If an object with both both <code>visible</code> and <code>clickable</code> is clicked, then mouse events will be sent for it (see <a href="#events">Events</a>), and the <code>GameObj</code> method &#39;obj.clicked()&#39; can also be used to detect click on the object.</p>
<blockquote>
<p>When a click occurs in the application window, the topmost object <code>visible</code> and <code>clickable</code> object that intersects the click location is considered to be the target of the click for mouse events. However, the functions <code>ct.clicked()</code>, <code>ct.clickX()</code>, and <code>ct.clickY()</code> can still be used to check for the click as well.</p>
</blockquote>
<h3 id="autodelete">autoDelete</h3>
<pre><code>boolean autoDelete     // auto delete if it goes from on to off-screen
</code></pre><p>If you set the <code>autoDelete</code> field of an object to <code>true</code> (default <code>false</code>), then the object will be automatically deleted if it moves off-screen (outside of the application window).</p>
<blockquote>
<p>If an object is created initially off-screen, it will not be automatically deleted until it has moved on-screen, then off-screen again.</p>
</blockquote>
<h3 id="group">group</h3>
<pre><code>String group
</code></pre><p>The <code>group</code> field is an optional name that you can assign to an object that will cause the function <code>ct.clearGroup()</code> to delete all objects with the matching group name. The default group name of an object is &quot;&quot; (empty string)</p>
<hr>
<h2 id="gameobj-methods">GameObj Methods</h2>
<p>The following method functions must be called on an existing <code>GameObj</code> object (see <a href="#gameobj-creation">GameObj Creation</a>). In the syntax shown, the <code>obj</code> can be any variable of type <code>GameObj</code>.</p>
<h3 id="obj-gettype-">obj.getType()</h3>
<pre><code>String obj.getType( )
</code></pre><p>Return the type name of the <code>GameObj</code> object, which is one of: <code>&quot;circle&quot;</code>, <code>&quot;rect&quot;</code>, <code>&quot;line&quot;</code>, <code>&quot;text&quot;</code>, or <code>&quot;image&quot;</code>.</p>
<h3 id="obj-gettext-">obj.getText()</h3>
<pre><code>String obj.getText( )
</code></pre><p>Return the text of the object. For a <code>&quot;text&quot;</code> object, this is the visible text. For other objects, this is just a string kept inside the object, which can be used to identity or describe the object. For an <code>&quot;image&quot;</code> object,  the text defaults to the image filename, but you can change it to something else (see <code>obj.setText</code> below).</p>
<blockquote>
<p>The <code>obj.toString()</code> method (see below) includes the object text in the description of an object.</p>
</blockquote>
<h3 id="obj-settext-">obj.setText()</h3>
<pre><code>obj.setText( String s )
</code></pre><p>Set the text of an object. If the object is a text object, setting the text will cause the visible text to change. For other object types, the text is simply stored in the object (See <code>obj.getText( )</code> above).</p>
<h3 id="obj-tostring-">obj.toString()</h3>
<pre><code>String obj.toString( )
</code></pre><p>Return a string description of the object suitable for printing for diagnostic purposes (via <code>ct.println()</code>, <code>ct.log()</code>, etc.) The string will include the type name of the object, the (<code>x</code>, <code>y</code>) coordinates rounded to the nearest integer, and the text of the object, if any. The entire string is enclosed in square brackets.</p>
<h5 id="examples-">Examples:</h5>
<pre><code>[circle at (70, 25)]
[text at (50, 10) &quot;Score 3200&quot;]
[image at (21, 83) &quot;goldfish.png&quot;]
[image at (21, 83) &quot;hero&quot;]
[rect at (50, 100) &quot;bottom wall&quot;]
</code></pre><h3 id="obj-setsize-">obj.setSize()</h3>
<pre><code>obj.setSize( double width, double height )
</code></pre><p>Set the size of the object using <code>width</code> and <code>height</code>. This is just a convenience method that is equivalent to setting both the <code>width</code> and <code>height</code> fields. Note that different types of objects react differently to changes in width or height. (see <a href="#width-height">width, height</a> above).</p>
<h3 id="obj-align-">obj.align()</h3>
<pre><code>obj.align( String a )
obj.align( String a, boolean adjustY )
</code></pre><p>Set the alignment of the object, which is where the object is positioned on screen relative to its <code>x</code> and <code>y</code> coordinates. By default, objects are positioned by their center point, so that (<code>x</code>, <code>y</code>) is at the horizontal and vertical center of the object.</p>
<p>The following alignments are supported, which describe the location of (<code>x</code>, <code>y</code>) on the object:</p>
<pre><code>&quot;top left&quot;
&quot;top&quot;             or &quot;top center&quot;
&quot;top right&quot;
&quot;left&quot;            (vertically centered)
&quot;center&quot;          (vertically centered)
&quot;right&quot;           (vertically centered)
&quot;bottom left&quot;
&quot;bottom&quot;          or &quot;bottom center&quot;
&quot;bottom right&quot;
</code></pre><p>If <code>adjustY</code> is included and <code>true</code>, then the object will be automatically repositioned to maintain its relative vertical position in the application window if the window is resized and changes aspect ratio. This can be used to easily make objects stick to the bottom of the window, or stay in the vertical center of the window, etc.</p>
<p>Note that all objects always automatically adjust their horizontal position when the window is resized (because display coordinates are relative to a width of 100), and that vertical positions are also relative to the window&#39;s overall size, and thus also adjust when the window resizes. The effect of <code>adjustY</code> is only relevant to help adjust for changes in the aspect ratio of the window.</p>
<h3 id="obj-setfillcolor-">obj.setFillColor()</h3>
<pre><code>obj.setFillColor( String color )
</code></pre><p>Set the fill color of the object (text color for text objects) to the pre-defined color named <code>color</code>. See <a href="#color-names">Color Names</a>. If <code>color</code> is <code>null</code> then the fill is removed from the object.</p>
<h3 id="obj-setfillcolorrgb-">obj.setFillColorRGB()</h3>
<pre><code>obj.setFillColorRGB( int r, int g, int b )
</code></pre><p>Set the fill color of the object (text color for text objects) to the custom RGB color with components <code>r</code>, <code>g</code>, and <code>b</code> in the range 0-255.</p>
<h3 id="obj-setlinecolor-">obj.setLineColor()</h3>
<pre><code>obj.setLineColor( String color )
</code></pre><p>Set the line color of the object (the outline stroke color for objects other than line objects) to the pre-defined color named <code>color</code>. See <a href="#color-names">Color Names</a>. If <code>color</code> is <code>null</code> then the stroke is removed from the object.</p>
<h3 id="obj-setlinecolorrgb-">obj.setLineColorRGB()</h3>
<pre><code>obj.setLineColorRGB( int r, int g, int b )
</code></pre><p>Set the line color of the object (the outline stroke color for objects other than line objects) to the custom RGB color with components <code>r</code>, <code>g</code>, and <code>b</code> in the range 0-255.</p>
<h3 id="obj-getlayer-">obj.getLayer()</h3>
<pre><code>int obj.getLayer( )
</code></pre><p>Return the layer number for the object. See <code>obj.setLayer()</code> below.</p>
<h3 id="obj-setlayer-">obj.setLayer()</h3>
<pre><code>obj.setLayer( int layer )
</code></pre><p>Set the layer number for the object. The layer number can be used to easily control the stacking order of groups of objects. The default layer is 1, and you can set any integer value. After the background color or image, object layers are drawn from the lowest value first (in the back) to the highest values (in the front).</p>
<p>Within a layer, objects are drawn in the order that they were created or set to that layer number. Calling <code>obj.setLayer()</code> always re-inserts an object at the top of that layer.</p>
<h3 id="obj-delete-">obj.delete()</h3>
<pre><code>obj.delete( )
</code></pre><p>Remove and delete the object from the screen.</p>
<blockquote>
<p>Attempting to access the fields or methods of an object after it has been deleted may result in unpredictable behavior.</p>
</blockquote>
<h3 id="obj-clicked-">obj.clicked()</h3>
<pre><code>boolean obj.clicked( )
</code></pre><p>Return <code>true</code> if the object was clicked or touched during the last update cycle. Only objects with both the <code>visible</code> and <code>clickable</code> fields set to <code>true</code> will receive mouse/touch input.</p>
<p>Calling this method for an object every time during your <code>update</code> function will detect any clicks on the object.</p>
<blockquote>
<p>If more than one visible and clickable object intersects with the location of a click or touch, the topmost one will receive the click. Objects that are not both visible and clickable are ignored when determining the object that was clicked.</p>
</blockquote>
<h3 id="obj-containspoint-">obj.containsPoint()</h3>
<pre><code>boolean obj.containsPoint( double x, double y )
</code></pre><p>Return <code>true</code> if the point (<code>x</code>, <code>y</code>) lies within the interior of the object, or on the border.</p>
<blockquote>
<p>Text and image objects use the rectangular bounds of the object for the test. Circles (or ellipses) use the curved shape. Lines have no interior and always return <code>false</code>.</p>
</blockquote>
<h3 id="obj-hit-">obj.hit()</h3>
<pre><code>boolean obj.hit( GameObj obj2 )
</code></pre><p>Return <code>true</code> if the object currently intersects with another object <code>obj2</code>. If you call this method every time in your <code>update</code> function, it can be used to test if/when two objects &quot;hit&quot; each other.</p>
<hr>
<h2 id="java-math-class-methods-and-fields-supported">Java Math Class Methods and Fields Supported</h2>
<p>The following fields and methods from the Java <code>Math</code> class are supported.</p>
<pre><code>double  Math.E
double  Math.PI
double  Math.abs( double a )
int     Math.abs( int a )
double  Math.acos( double a )
double  Math.asin( double a )
double  Math.atan( double a )
double  Math.atan2( double y, double x)
double  Math.ceil( double a )
double  Math.cos( double a )
double  Math.cosh( double a )
double  Math.exp( double a )
double  Math.floor( double a )
double  Math.log( double a )
double  Math.log10( double a )
double  Math.max( double a, double b )
int     Math.max( int a, int b )
double  Math.min( double a, double b )
int     Math.min( int a, int b )
double  Math.pow( double a, double b )
double  Math.sin( double a )
double  Math.sinh( double a )
double  Math.sqrt( double a )
double  Math.tan( double a )
double  Math.tanh( double a )
</code></pre><hr>
<h2 id="java-string-class-methods-supported">Java String Class Methods Supported</h2>
<p>The following methods from the Java <code>String</code> class are supported.</p>
<pre><code>int      str.compareTo( String str2 )
boolean  str.equals( String str2 )
int      str.indexOf( String strFind )
int      str.length()
String   str.substring( int beginIndex )
String   str.substring( int beginIndex, int endIndex )
String   str.toLowerCase()
String   str.toUpperCase()
String   str.trim()
</code></pre><hr>
<h2 id="events">Events</h2>
<p>The following functions, if defined in your program, will be called when indicated. Note that unlike all of the other functions and methods above, These functions are <em>implemented</em> in your program (you write the body of the function) and are <em>called</em> by the runtime system with appropriate. They are called in response to &quot;events&quot; happening in your application.</p>
<p>Implementing any of these functions is optional and &quot;for your information&quot;. They are not necessary to use other functions and features of the system. For example, if you don&#39;t implement any of the mouse event functions, you can still call functions such as <code>ct.clicked()</code> to test for mouse clicks.</p>
<blockquote>
<p><strong>Tip:</strong> If your program has complex mouse or keyboard handling (for example, many objects to check for clicks and many keys to test), then doing your work in the event functions will be more efficient than making many tests in your <code>update</code> function.</p>
</blockquote>
<h3 id="start-">start()</h3>
<pre><code>void start( )
</code></pre><p>The <code>start</code> function is called once at the beginning of your program. This is good place to create most of the objects for your program (except for any objects that get created as a result of an action that occurs while the application is running).</p>
<h3 id="update-">update()</h3>
<pre><code>void update( )
</code></pre><p>The <code>update</code> function is called at the beginning of each update cycle. Update cycles start after the <code>start</code> function has completed and then repeat continuously at 60 times per second.</p>
<p>One use of update cycles is to achieve object motion and animation. For example, if you move an object 1 display unit to the right in your <code>update</code> function, then the object will move continuously at 60 units per second.</p>
<p>Another use of update cycles is to poll (check repeatedly) for user input, using functions such as <code>ct.clicked()</code>, <code>ct.keyPressed()</code>, and <code>ct.keyTyped()</code>, and the <code>GameObj</code> method <code>obj.clicked()</code>.</p>
<p>You can also use update cycles to test repeatedly for object interactions that can occur during any update cycle when objects are moving. You can examine object fields such as <code>x</code> and <code>y</code> directly, call the <code>GameObj</code> methods <code>obj.containsPoint()</code> and <code>obj.hit()</code>, call the function <code>ct.distance()</code> or write any code you want that tests what you need to detect.</p>
<p>Finally, note that you can call <code>ct.getTimer()</code> to detect the passage of certain amounts of time if you want.</p>
<blockquote>
<p>A common mistake is to create <code>GameObj</code> objects in the <code>update</code> function in a way that causes many copies of the object to be created over and over. Note that you should <em>not</em> call functions like <code>ct.circle()</code> to &quot;draw&quot; a circle for each frame in an animation. Instead, you typically want to call <code>ct.circle()</code> to create the object once in your <code>start</code> function, then modify the existing circle in your <code>update</code> function.</p>
</blockquote>
<h3 id="onmousepress-">onMousePress()</h3>
<pre><code>void onMousePress( GameObj obj, double x, double y )
</code></pre><p>This event is called each time a mouse click or touch is detected. The point (<code>x</code>, <code>y</code>) is the location of the click in display coordinates (relative to the top-left of the application window).</p>
<p>If <code>obj</code> is not <code>null</code>, then it indicates that the click occured on that object. Note that <code>GameObj</code> objects must have both their <code>visible</code> and <code>clickable</code> fields set to <code>true</code> to receive clicks. If <code>obj</code> is null, then the click occured outside of any clickable object.</p>
<h3 id="onmousedrag-">onMouseDrag()</h3>
<pre><code>void onMouseDrag( GameObj obj, double x, double y )
</code></pre><p>After a click or touch has happened, if the user&#39;s mouse or finger is still &quot;down&quot; and drags across the screen, then <code>onMouseDrag</code> will be called each time the position changes (you may get many calls in succession). The point (<code>x</code>, <code>y</code>) is the new location of the mouse/finger.</p>
<p>If <code>obj</code> is not <code>null</code>, then it indicates that the original click occured on that clickable object (see <code>onMousePress</code> above).</p>
<blockquote>
<p>Note: Once a click occurs on a clickable <code>GameObj</code>, all drag events will be sent indicating this <code>obj</code>, even if the (<code>x</code>, <code>y</code>) location is no longer on the object (<code>GameObj</code> objects automatically take the mouse/touch &quot;focus&quot; when clicked).</p>
</blockquote>
<h3 id="onmouserelease-">onMouseRelease()</h3>
<pre><code>void onMouseRelease( GameObj obj, double x, double y )
</code></pre><p>This event is called when a mouse click or touch ends, and the mouse button or finger is &quot;released&quot;. The point (<code>x</code>, <code>y</code>) is the location of the mouse/finger at the time of the release.</p>
<p>If <code>obj</code> is not <code>null</code>, then it indicates that the original click occured on that clickable object (see <code>onMousePress</code> above).</p>
<blockquote>
<p>Note: When a click occurs on a clickable <code>GameObj</code>, the release event will always be sent indicating this <code>obj</code>, even if the (<code>x</code>, <code>y</code>) location of the release is no longer on the object.</p>
</blockquote>
<h3 id="onkeypress-">onKeyPress()</h3>
<pre><code>void onKeyPress( String keyName )     // key code name e.g. &quot;a&quot;, &quot;up&quot;
</code></pre><p>This event is called when a keyboard key has been pressed down. The event is only called once for each separate press/release, when the key is first pressed down, reagardless of how long the key is held down.</p>
<p>The <code>keyName</code> is the name of the key. See <a href="#key-names">Key Names</a>.</p>
<h3 id="onkeyrelease-">onKeyRelease()</h3>
<pre><code>void onKeyRelease( String keyName )   // key code name e.g. &quot;a&quot;, &quot;up&quot;
</code></pre><p>This event is called when the keyboard key named <code>keyName</code> has been released (after being pressed). See <a href="#key-names">Key Names</a>.</p>
<h3 id="onchartyped-">onCharTyped()</h3>
<pre><code>void onCharTyped( String ch )     // &quot;a&quot;, &quot;A&quot;, &quot;$&quot;, etc.
</code></pre><p>This event is called when keyboard action results in a printable character being generated.</p>
<blockquote>
<p>Unlike the key names used by <code>onkeyPressed</code> above, the <code>ch</code> here is a printable character including the appropriate shift status (e.g. &quot;A&quot; if a shifted &quot;a&quot; is typed, &quot;$&quot; or &quot;4&quot;, &quot;+&quot; vs. &quot;=&quot;, etc.). Only printable characters are detected, so key sequences such as Ctrl+C do not result in characters.</p>
</blockquote>
<blockquote>
<p>Note that some platforms may have keys that auto-repeat, so you may get multiple <code>onCharTyped</code> events if a key is held down.</p>
</blockquote>
<h3 id="onresize-">onResize()</h3>
<pre><code>void onResize()
</code></pre><p>This event is called if the application window is resized by the user, to allow you to change any object positions or otherwise react as desired. The contents of your application scale automatically relative to the window size, so you don&#39;t need to do anything in the normal case. However, if your object layout depends on the window aspect ratio or the physical pixel size, then you can determine these as follows:</p>
<pre><code>double aspectRatio = ct.getWidth() / ct.getHeight();
int pixelWidth = ct.round( ct.getWidth() * ct.getPixelsPerUnit() );
int pixelHeight = ct.round( ct.getHeight() * ct.getPixelsPerUnit() );
</code></pre><blockquote>
<p>Some systems resize windows continuously in response to the user re-sizing the window frame, so you may receive many <code>onResize</code> events in succession.</p>
</blockquote>
<hr>
<h2 id="appendix-pre-defined-names">Appendix: Pre-Defined Names</h2>
<h3 id="color-names">Color Names</h3>
<p>The following named colors are supported. If a string used as a color is not recognized then &quot;gray&quot; is used.</p>
<pre><code>Color Name       (red, green, blue)
----------       ------------------
&quot;black&quot;          (0, 0, 0)
&quot;white&quot;          (255, 255, 255)
&quot;red&quot;            (255, 0, 0)
&quot;green&quot;          (0, 255, 0)
&quot;blue&quot;           (0, 0, 255)
&quot;cyan&quot;           (0, 255, 255)
&quot;magenta&quot;        (255, 0, 255)
&quot;yellow&quot;         (255, 255, 0)

&quot;gray&quot;           (127, 127, 127)
&quot;orange&quot;         (255, 127, 0)
&quot;pink&quot;           (255, 192, 203)
&quot;purple&quot;         (64, 0, 127)

&quot;light gray&quot;     (191, 191, 191)
&quot;light red&quot;      (255, 127, 127)
&quot;light green&quot;    (127, 255, 127)
&quot;light blue&quot;     (127, 127, 255)
&quot;light cyan&quot;     (127, 255, 255)
&quot;light magenta&quot;  (255, 127, 255)
&quot;light yellow&quot;   (255, 255, 127)

&quot;dark gray&quot;      (64, 64, 64)
&quot;dark red&quot;       (127, 0, 0)
&quot;dark green&quot;     (0, 127, 0)
&quot;dark blue&quot;      (0, 0, 127)
&quot;dark cyan&quot;      (0, 127, 127)
&quot;dark magenta&quot;   (127, 0, 127)
&quot;dark yellow&quot;    (127, 127, 0)

</code></pre><h3 id="key-names">Key Names</h3>
<p>The following key names are supported. Note that key names refer to a hardware key, not a typed character, so typing &#39;A&#39; uses the &quot;a&quot; key, and typing &#39;$&#39; uses the &quot;4&quot; key.</p>
<pre><code>&quot;a&quot; to &quot;z&quot;                     (alphabet keys)
&quot;0&quot; to &quot;9&quot;                     (top row number keys)
&quot;numPad0&quot; to &quot;numPad9&quot;         (number pad digit keys)
&quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;  (arrow keys)
&quot;space&quot;                        (space bar)
&quot;enter&quot;                        (enter or return key)
&quot;tab&quot;                          (tab key)
&quot;backspace&quot;                    (backspace or delete left key)
&quot;escape&quot;                       (esc key)
</code></pre>

</article>