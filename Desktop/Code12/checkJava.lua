-----------------------------------------------------------------------------------------
--
-- checkJava.lua
--
-- Semantic Analysis and Error Checking for Java for the Code 12 Desktop app
--
-- (c)Copyright 2018 by David C. Parker 
-----------------------------------------------------------------------------------------

-- Code12 modules
local err = require( "err" )
local javaTypes = require( "javaTypes" )
local apiTables = require( "apiTables" )   -- note: generated by the "Make API" tool


-- The checkJava module
local checkJava = {}



-- Type analysis tables
local methods = {}      -- map method names to { node = token, vt = vt, params = {} }
local classVars = {}    -- map instance var name to { node = token, vt = vt } or strCorrectName
local localVars = {}    -- map local var name to { node = token, vt = vt } or strCorrectName
local vtNodes = {}      -- types of expression nodes determined on a line


--- Misc Analysis Functions --------------------------------------------------

-- Find user-defined methods in parseTrees and put them in the methods table.
-- Return true if successful, false if an error occured.
local function getMethods( parseTrees )
	for i = 1, #parseTrees do
		local tree = parseTrees[i]
		assert( tree.t == "line" )
		local p = tree.p
		local nodes = tree.nodes
		if p == "eventFn" then
			-- Code12 event func (e.g. setup, update)
			-- TODO: Check that the API signature is what is needed for this event
		elseif p == "func" then
			-- User-defined function
			local nameNode = nodes[2]
			local fnName = nameNode.str
			if nameNode.tt ~= "ID" or fnName:find("%.") then 
				err.setErrNode( nameNode, "User-defined function names cannot contain a dot (.)" )
			else
				-- Build the parameter table
				local paramTable = {}
				local params = nodes[4].nodes
				for i = 1, #params do
					local param = params[i]
					local vtParam, name = javaTypes.vtAndNameFromParam( param )
					paramTable[#paramTable + 1] = { name = name, vt = vtParam }
				end
				-- Add entry to methods table
				methods[fnName] = { 
					node = nameNode,
					vt = javaTypes.vtFromRetType( nodes[1] ), 
					params = paramTable
				}
			end
		end
		if err.hasErr() then
			return false
		end
	end
	return true
end

-- Look up the name in nameToken in the knownNames table.
-- If the name is found and the entry is a record (table) then return the record.
-- If an entry in the knownNames table has an index differing only in case, then
-- set the error state to a description of the error and return 
-- (nil, strCorrectCase, entryCorrectCase), where strCorrectCase is the correct name
-- and entryCorrectCase is the entry record for the correct name, otherwise return nil.
local function lookupID( nameToken, knownNames )
	if nameToken.tt == "ID" then
		local result = knownNames[nameToken.str]
		if type(result) == "string" then
			local strCorrectCase = result
			result = knownNames[result]  -- get the correct entry
			if result then
				err.setErrNode( nameToken, 
						"Names are case-sensitive, known name is \"%s\"", strCorrectCase )
				return nil, strCorrectCase, result
			end
		end
		return result  -- table or nil
	end
	return nil
end


--- Misc Type Functions ------------------------------------------------------

-- Return the resulting numeric vt for an operation on vt1 and vt2 (both numeric)
local function vtNumber( vt1, vt2 )
	local vt = vt1 + vt2    -- int promotes to double
	if vt > 1 then
		return 1   -- both were double, too bad we don't have bitwise OR here.
	end
	return vt
end

-- Return the value type (vt) for a variable node.
-- If the variable is undefined, then set the error state and return nil.
local function vtVar( varNode )
	assert( varNode.tt == "ID" )
	local varName = varNode.str
	local varFound = lookupID( varNode, localVars )
	if varFound == nil then
		varFound = lookupID( varNode, classVars )
	end
	if varFound == nil then
		err.setErrNode( varNode,  "Undefined variable %s", varName )
		return nil
	end
	return varFound.vt
end

-- Return the value type (vt) for an lValue node.
-- If there is an error, then set the error state and return nil.
local function vtLValueNode( lValue )
	assert( lValue.t == "lValue" )
	local p = lValue.p
	local nodes = lValue.nodes
	if p == "var" then
		return vtVar( nodes[1] )
	elseif p == "index" then
		-- indexing an array
		local indexExpr = nodes[3]
		local vtIndex = checkJava.vtCheckExpr( indexExpr )
		if vtIndex ~= 0 then
			err.setErrNode( indexExpr, "Array index must be an integer value" )
			return nil
		end
		vt = vtVar( nodes[1] )
		if type(vt) ~= "table" then
			err.setErrNodeAndRef( nodes[2], nodes[1], 
					"An index in [brackets] can only be applied to an array" )
			return nil
		end
		return vt.vt
	elseif p == "this" then
		-- explicit reference to class variable
		local varNode = nodes[3]
		if lookupID( varNode, classVars ) == nil then
			err.setErrNodeAndRef( varNode, nodes[1],
					"Undefined class variable %s referenced with \"this\"", varNode.str )
			return nil
		end
		return vtVar( varNode )
	elseif p == "field" then
		-- Public field access (only possible with Math or GameObj)
		local object = nodes[1]
		local field = nodes[3]
		-- Determine the class
		local className
		assert( object.tt == "ID" )
		local objName = object.str
		if objName == "Math" then   -- Math has all static members
			className = "Math"
		else
			local vtObj = vtVar( object )
			if vtObj == "GameObj" then
				className = vtObj
			else
				err.setErrNode( object, "Cannot access data fields of type %s",
						javaTypes.typeNameFromVt( vtObj ))
				return nil
			end
		end
		local class = apiTables[className]

		-- Look up the field
		assert( field.tt == "ID" )
		local fieldName = field.str
		local vtField = class.fields[fieldName]
		if vtField == nil then
			checkCaseMismatch( field, class.fields )
			err.setErrNodeAndRef( field, object, 
					"Unknown field \"%s\" for class %s",
					fieldName, className )
			return nil
		end
		return vtField
	end
	error( "Unknown lValue pattern " .. p )
end


--- Type Analysis of expressions  --------------------------------------------

-- Forward decl for mutual recursion
local vtExprNode

-- The following local functions are all hashed into from the fnVtExprPatterns
-- table below. They all return the vt of a particular pattern of an expr node
-- (primaryExpr or expr with binary op) given the children nodes array.
-- If there is an error, they set the error state and return nil.

-- primaryExpr pattern: NUM
local function vtExprNUM( nodes )
	return ((nodes[1].str:find("%.") and 1) or 0)   -- double or int
end

-- primaryExpr pattern: BOOL
local function vtExprBOOL( nodes )
	return true
end

-- primaryExpr pattern: NULL
local function vtExprNULL( nodes )
	return "null"
end

-- primaryExpr pattern: STR
local function vtExprSTR( nodes )
	return "String"
end

-- primaryExpr pattern: exprParens
local function vtExprExprParens( nodes )
	return vtExprNode( nodes[2] )
end

-- primaryExpr pattern: neg
local function vtExprNeg( nodes )
	local expr = nodes[2]
	local vt = vtExprNode( expr )
	if type(vt) ~= "number" then
		err.setErrNodeAndRef( nodes[1], expr, 
				"The negate operator (-) can only apply to numbers" )
		return nil
	end
	return vt
end

-- primaryExpr pattern: !
local function vtExprNot( nodes )
	local expr = nodes[2]
	local vt = vtExprNode( expr )
	if vt ~= true then
		err.setErrNodeAndRef( nodes[1], expr, 
				"The not operator (!) can only apply to boolean values" )
		return nil
	end
	return vt
end

-- primaryExpr pattern: call
local function vtExprCall( nodes )
	return checkJava.vtCheckCall( nodes[1], nodes[3] )
end

-- primaryExpr pattern: lValue
local function vtExprLValue( nodes )
	return vtLValueNode( nodes[1] )
end

-- expr pattern: +
local function vtExprPlus( nodes )
	-- May be numeric add or string concat, depending on the operands
	assert( nodes[2].tt == "+" )
	local vtLeft = vtExprNode( nodes[1] )
	local vtRight = vtExprNode( nodes[3] )
	if type(vtLeft) == "number" and type(vtRight) == "number" then
		return vtNumber( vtLeft, vtRight )
	elseif vtLeft == "String" and vtRight == "String" then
		return "String"
	elseif vtLeft == "String" or vtRight == "String" then
		-- Check if the other operand can be promoted to string (numbers only)
		local exprOther, vtOther
		if vtLeft == "String" then
			exprOther = nodes[3]
			vtOther = vtRight
		else
			exprOther = nodes[1]
			vtOther = vtLeft
		end
		if type(vtOther) == "number" then
			return "String"   -- the number will promote to a string 
		elseif vtOther == "GameObj" then
			err.setErrNodeAndRef( nodes[2], exprOther, 
					"The (+) operator cannot be used on GameObj objects directly. Use the toString() method." )
		else
			err.setErrNodeAndRef( nodes[2], exprOther, 
					"The (+) operator can only apply to numbers or Strings" )
		end
	else
		-- Find the side that is wrong
		local exprOther
		if vtLeft == "String" or type(vtLeft) == "number" then
			exprOther = nodes[3]
		else
			exprOther = nodes[1]
		end
		err.setErrNodeAndRef( nodes[2], exprOther, 
				"The (+) operator can only apply to numbers or Strings" )
	end
	return nil
end

-- expr patterns: -, *, /, %
local function vtExprNumeric( nodes )
	-- Both sides must be numeric, result is number
	local vtLeft =  vtExprNode( nodes[1] )
	local vtRight = vtExprNode( nodes[3] )
	if type(vtLeft) == "number" and type(vtRight) == "number" then
		return vtNumber( vtLeft, vtRight )
	end
	local exprErr = ((type(vtLeft) ~= "number" and nodes[1]) or nodes[3])
	err.setErrNodeAndRef( nodes[2], exprErr, 
			"Numeric operator (%s) can only apply to numbers", nodes[2].str )
	return nil
end

-- expr patterns: &&, ||
local function vtExprLogical( nodes )
	-- Both sides must be boolean, result is boolean
	local vtLeft = vtExprNode( nodes[1] )
	local vtRight = vtExprNode( nodes[3] )
	if vtLeft == true and vtRight == true then
		return true
	end
	local exprErr = ((vtLeft ~= true and nodes[1]) or nodes[3])
	err.setErrNodeAndRef( nodes[2], exprErr, 
			"Logical operator (%s) can only apply to boolean values", nodes[2].str )
	return nil
end

-- expr patterns: <, >, <=, >=
local function vtExprInequality( nodes )
	-- Both sides must be numeric, result is boolean
	local vtLeft = vtExprNode( nodes[1] )
	local vtRight = vtExprNode( nodes[3] )
	if type(vtLeft) == "number" and type(vtRight) == "number" then
		return true
	end
	local exprErr = ((type(vtLeft) ~= "number" and nodes[1]) or nodes[3])
	err.setErrNodeAndRef( nodes[2], exprErr, 
			"Inequality operator (%s) can only apply to numbers", nodes[2].str )
	return nil
end

-- expr patterns: ==, !=
local function vtExprEquality( nodes )
	local left = nodes[1]
	local right = nodes[3]
	local vtLeft = vtExprNode( left)
	local vtRight = vtExprNode( right )
	if javaTypes.canCompareVts( vtLeft, vtRight ) then
		return true
	end
	err.setErrNodeAndRef( left, right, "Cannot compare %s to %s", 
		javaTypes.typeNameFromVt( vtLeft ), javaTypes.typeNameFromVt( vtRight ) )
	return nil
end

-- Since there are so many primaryExpr and expr patterns, we hash them to functions
local fnVtExprPatterns = {
	-- primaryExpr patterns
	["NUM"]         = vtExprNUM,
	["BOOL"]        = vtExprBOOL,
	["NULL"]        = vtExprNULL,
	["STR"]         = vtExprSTR,
	["exprParens"]  = vtExprExprParens,
	["neg"]         = vtExprNeg,
	["!"]           = vtExprNot,
	["call"]        = vtExprCall,
	["lValue"]      = vtExprLValue,
	-- binary operators
	["+"]           = vtExprPlus,
	["-"]           = vtExprNumeric,
	["*"]           = vtExprNumeric,
	["/"]           = vtExprNumeric,
	["%"]           = vtExprNumeric,
	["&&"]          = vtExprLogical,
	["||"]          = vtExprLogical,
	["<"]           = vtExprInequality,
	[">"]           = vtExprInequality,
	["<="]          = vtExprInequality,
	[">="]          = vtExprInequality,
	["=="]          = vtExprEquality,
	["!="]          = vtExprEquality,
}

-- Return the value type (vt) for an expr, primaryExpr, or lValue node.
-- Also remember the node's type in vtNodes for possible later calls 
-- to checkJava.vtKnownExpr().
-- If an error is found, set the error state and return nil.
function vtExprNode( node )
	local vt = nil
	if node.t == "lValue" then
		vt = vtLValueNode( node )
	else
		assert( node.t == "expr" )
		-- Look up and call the correct vt function above
		local fnVt = fnVtExprPatterns[node.p]
		if fnVt == nil then
			error( "vtExprNode: Unknown expr pattern " .. p )
		end
		vt = fnVt( node.nodes )
	end
	-- Remember and return the result
	vtNodes[node] = vt       
	return vt
end


--- Post Check Analysis Functions  -------------------------------------------

-- If expr is an integer divide that might have a remainder, 
-- then set the error state and return true, otherwise return false.
-- The expr most be on the current line after type analysis is completed.
local function isBadIntDivide( expr )
	if expr.p == "/" and checkJava.vtKnownExpr( expr ) == 0 then
		local nodes = expr.nodes
		local left = nodes[1]
		local right = nodes[3]

		if left.p == "NUM" and right.p == "NUM" then
			-- Both sides are constant so we can check for a remainder
			local n = tonumber( left.nodes[1].str )
			local d = tonumber( right.nodes[1].str )
			local r = n / d
			if r == math.floor( r ) then
				return false   -- no remainder, so OK as-is
			else
				err.setErrNode( expr, "Integer divide has remainder. Use double or ct.intDiv()" )
				return true
			end
		else
			-- The remainder can't be determined, but Code12 doesn't allow this
			-- because chances are the programmer made a mistake.
			err.setErrNode( expr, "Integer divide may lose remainder. Use double or ct.intDiv()" )
			return true
		end
	end
	return false
end


--- Module Functions ---------------------------------------------------------

-- Check and return the value type (vt) for an expr, primaryExpr, or lValue node.
-- If an error is found, set the error state and return nil.
function checkJava.vtCheckExpr( node )
	local vt = vtExprNode( node )
	checkJava.postCheck( node )
	return vt
end

-- Return the type of an expression that has already been checked and determined
-- on the current line, or nil if unknown.
function checkJava.vtKnownExpr( node )
	return vtNodes[node]
end

-- Return true if the given variable node is a defined class variable.
function checkJava.isClassVar( varNode )
	return classVars[varNode.str] ~= nil
end

-- Define the class variable with the given nameNode and type (vt, isArray).
-- Return true if successful, false if error.
function checkJava.defineClassVar( nameNode, vt, isArray )
	if vt == nil then
		return false
	end
	if isArray then
		vt = { vt = vt }   -- make vt into array of specified type
	end

	-- Make sure we don't already have an error because we may clear
	-- the error state below.
	if err.hasErr() then
		return false
	end

	-- Check for existing definition
	local varName = nameNode.str
	local varFound, nameCorrectCase, varCorrectCase = lookupID( nameNode, classVars )
	if varFound then
		err.setErrNodeAndRef( nameNode, varFound.node, 
				"Variable %s was already defined", varName )
		return false
	elseif varCorrectCase then
		err.clearErr()
		err.setErrNodeAndRef( nameNode, varCorrectCase, 
				"Variable %s differs only by case from existing variable %s", 
				varName, nameCorrectCase )
		return false
	end

	-- Define it and the case-insensitive lower-case version as well if necessary
	classVars[varName] = { node = nameNode, vt = vt }
	local varNameLower = string.lower( varName )
	if varNameLower ~= varName then
		classVars[varNameLower] = varName
	end
	return true
end

-- Define the local variable with the given nameNode and type (vt, isArray).
-- Return true if successful, false if error.
function checkJava.defineLocalVar( nameNode, vt, isArray )
	if vt == nil then
		return false
	end
	if isArray then
		vt = { vt = vt }   -- make vt into array of specified type
	end

	-- Check for existing definition
	local varName = nameNode.str
	local varFound, nameCorrectCase, varCorrectCase = lookupID( nameNode, localVars )
	if varFound == nil then
		varFound, nameCorrectCase, varCorrectCase = lookupID( nameNode, classVars )
	end
	if varFound then
		err.setErrNodeAndRef( nameNode, varFound.node, 
				"Variable %s was already defined", varName )
		return false
	elseif varCorrectCase then
		err.clearErr()
		err.setErrNodeAndRef( nameNode, varCorrectCase, 
				"Variable %s differs only by case from existing variable %s", 
				varName, nameCorrectCase )
		return false
	end

	-- Define it and the case-insensitive lower-case version as well if necessary
	localVars[varName] = { node = nameNode, vt = vt }
	local varNameLower = string.lower( varName )
	if varNameLower ~= varName then
		localVars[varNameLower] = varName
	end
	return true
end

-- Clear then init the local variable state for a new function with the paramList
function checkJava.initLocalVars( paramList )
	localVars = {}
	for i = 1, #paramList do
		local param = paramList[i]
		local vt = javaTypes.vtFromVarType( param.nodes[1] )
		if param.p == "array" then
			checkJava.defineLocalVar( param.nodes[4], vt, true )
		else
			checkJava.defineLocalVar( param.nodes[2], vt, false )
		end
	end
end

-- Do type checking on expr and then return true if the expr can be assigned to 
-- the given vt (value type) at node.
-- If the types are not compatible then set the error state and return false.
function checkJava.canAssignToVt( node, vt, expr )
	local vtExpr = checkJava.vtCheckExpr( expr )
	if javaTypes.vtCanAcceptVtExpr( vt, vtExpr ) then
		return true
	end

	-- Check for various type mismatch combinations
	local str
	if vtExpr == 1 and vt == 0 then          -- double assigned to int
		str = "Value of type double cannot be assigned to an int, use ct.round() or ct.toInt()"
	elseif vtExpr == 1 and vt == "String" then   -- double assigned to String
		str = "Value of type double cannot be assigned to a String, consider using ct.formatDecimal()"
	elseif vtExpr == 0 and vt == "String" then   -- int assigned to String
		str = "Integer value cannot be assigned to a String, consider using ct.formatInt()"
	elseif vtExpr == "String" and vt == 1 then   -- String assigned to double
		str = "A String cannot be assigned to a double, consider using ct.parseNumber()"
	elseif vtExpr == "String" and vt == 0 then   -- String assigned to int
		str = "A String cannot be assigned to an int, consider using ct.parseInt()"
	elseif vtExpr == "GameObj" and vt == "String" then
		str = "A GameObj cannot be assigned to a String, consider using the toString() method"
	else
		str = string.format( "Value of type %s cannot be assigned to type %s",
					javaTypes.typeNameFromVt( vtExpr ), javaTypes.typeNameFromVt( vt ) )
	end
	err.setErrNodeAndRef( node, expr, str )
	return false
end	

-- Return true if the expr can be assigned to the lValue node.
-- The expr must already have had type analysis done on it and have a vt field.
-- If the types are not compatible then set the error state and return false.
function checkJava.canAssignToLValue( lValue, expr )
	return checkJava.canAssignToVt( lValue, vtLValueNode( lValue ), expr )
end

-- Find a known ct API or user function with the given fnValue node.
-- Return the entry in the API or methods table if found.
-- If not found then set the error state and return nil.
local function findGlobalFunction( fnValue )
	if fnValue.tt ~= "ID" then
		return nil
	end
	local fnName = fnValue.str
	local method = apiTables["ct"].methods[fnName] or methods[fnName]
	if method == nil then
		-- Check for misspelling by case only
		local knownName = checkCaseMismatch( fnName, apiTables["ct"].methods )
								or checkCaseMismatch( fnName, methods )
		if knownName then
			local userMethod = methods[knownName]
			if userMethod then
				err.setErrNodeAndRef( fnValue, userMethod.node, 
						"Names are case-sensitive, did you mean \"%s\"?", knownName)
			else
				err.setErrNode( fnValue, 
						"Names are case-sensitive, should be \"%s\"", knownName)
			end
		else
			err.setErrNode( fnValue, "Undefined function %s", fnName )
		end
		return nil
	end
	return method
end

-- Find a known API method for the given non-ID fnValue node.
-- Return the method entry in the API tables if found.
-- If not found then set the error state and return nil.
local function findAPIMethod( fnValue )
	if fnValue.t ~= "fnValue" then
		return nil
	end
	local object = fnValue.nodes[1]
	local fnNode = fnValue.nodes[2]
	local fnName = fnNode.str

	-- Determine the class
	local className
	assert( object.tt == "ID" )
	local objName = object.str
	if objName == "Math" then   -- Math has all static methods
		className = "Math"
	else
		local vtObj = vtVar( object )
		if vtObj == "String" or vtObj == "GameObj" then
			className = vtObj
		else
			err.setErrNode( object, "Method call on invalid type (%s)",
					javaTypes.typeNameFromVt( vtObj ))
			return nil
		end
		-- TODO: Check object name
	end
	local class = apiTables[className]

	-- Look up the method
	method = class.methods[fnName]
	if method == nil then
		err.setErrNodeAndRef( fnNode, object, 
				"Unknown method \"%s\" for class %s",
				fnName, className )
		return nil
	end
	return method
end

-- Do type checking on a function or method call with the given fnValue and 
-- paramList nodes If there is an error then set the error state and return nil.
-- Return the return type vt if successful.
function checkJava.vtCheckCall( fnValue, paramList )
	-- Find the method
	local fnName
	local method
	if fnValue.tt == "ID" then
		-- A global API or user-defined method call
		fnName = fnValue.str
		method = findGlobalFunction( fnValue )
	else
		-- A method call
		assert( fnValue.t == "fnValue" )
		fnName = fnValue.nodes[2].str
		method = findAPIMethod( fnValue )
	end
	if method == nil then
		return nil
	end

	-- Check parameter count
	local params = paramList.nodes
	local min = method.min or #method.params
	if #params < min then
		err.setErrNodeAndRef( paramList, fnValue, 
				"Not enough parameters passed to %s (requires %d)", fnName, min )
		return nil
	elseif #params > #method.params then
		err.setErrNodeAndRef( paramList, fnValue, 
				"Too many parameters passed to %s", fnName )
		return nil
	end

	-- Check parameter types for validity and match with the API
	-- TODO: Handle overloaded Math methods
	for i = 1, #params do
		local expr = params[i]
		local vtPassed = checkJava.vtCheckExpr( expr )
		local vtNeeded = method.params[i].vt
		if not javaTypes.vtCanAcceptVtExpr( vtNeeded, vtPassed ) then
			err.setErrNode( expr, "Parameter %d of %s expects type %s, but %s was passed",
					i, fnName, javaTypes.typeNameFromVt( vtNeeded ), 
					javaTypes.typeNameFromVt( vtPassed ))
			return nil
		end
	end

	-- Result is the method's return type
	return method.vt 
end

-- Run post checks on the tree (and recursively downward), which must
-- be on the current line after type analysis has been done on it.
-- If there is an error then set the error state and return false
-- Return true if no errors were detected.
function checkJava.postCheck( tree )
	-- Check children recursively first
	local nodes = tree.nodes
	if nodes then
		for i = 1, #nodes do
			if not checkJava.postCheck( nodes[i] ) then
				return false
			end
		end
	end

	-- Check this node
	if tree.t == "expr" and isBadIntDivide( tree ) then
		return false
	end
	return true
end

-- Init the state for a new line in the program
function checkJava.initLine()
	-- We only need to store the known expression types on the current line
	vtNodes = {}
end

-- Init the state for a new program with the given parseTrees
-- Return true if successful, false if not.
function checkJava.initProgram( parseTrees )
	methods = {}
 	classVars = {}
 	localVars = {}
 	vtNodes = {}
 	err.initProgram()

	-- Get method types first, since vars can forward reference them
	return getMethods( parseTrees )
end


------------------------------------------------------------------------------

return checkJava
